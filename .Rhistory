View(cov_matrix)
############# Étape 4 : Décomposition de la matrice de covariance
eigen_result <- eigen(cov_matrix)
barplot(eigen_result$values, main = "Valeurs Propres",
xlab = "Composantes Principales", ylab = "Valeur Propre", col = "skyblue")
barplot(eigen_result$values, main = "Valeurs Propres",
xlab = "Composantes Principales", ylab = "Valeur Propre", col = "skyblue")
barplot(eigen_result$values, main = "Valeurs Propres",
xlab = "Composantes Principales", ylab = "Valeur Propre", col = "skyblue")
barplot(eigen_result$values, main = "Valeurs Propres",
xlab = "Composantes Principales", ylab = "Valeur Propre", col = "skyblue")
# Boxplot avant la mise à l'échelle
par(mfrow = c(1, 1))  # Diviser la fenêtre graphique en 1 ligne et 2 colonnes
barplot(eigen_result$values, main = "Valeurs Propres",
xlab = "Composantes Principales", ylab = "Valeur Propre", col = "skyblue")
############# Étape 4 : Décomposition de la matrice de covariance
(eigen_result <- eigen(cov_matrix))
cumulative_proportion <- cumsum(eigen_result$values) / sum(eigen_result$values)
cumulative_proportion
# Trouver le nombre de composantes principales pour atteindre 70% ou 80%
num_components_70 <- which(cumulative_proportion >= 0.7)[1]
num_components_80 <- which(cumulative_proportion >= 0.8)[1]
# Visualiser le graphique avec la règle du 70-80%
barplot(eigen_result$values, main = "Valeurs Propres",
xlab = "Composantes Principales", ylab = "Valeur Propre", col = "skyblue")
# Visualiser le graphique avec la règle du 70-80%
barplot(eigen_result$values, main = "Valeurs Propres",
xlab = "Composantes Principales", ylab = "Valeur Propre", col = "skyblue")
# Ajouter des lignes pour indiquer le 70% et 80% de la variance expliquée
abline(h = 0.7, col = "red", lty = 2)
abline(h = 0.8, col = "green", lty = 2)
# Trouver le nombre de composantes principales pour atteindre 70% ou 80%
(num_components_70 <- which(cumulative_proportion >= 0.7)[1])
(num_components_80 <- which(cumulative_proportion >= 0.8)[1])
#Visualiser un scree plot
# Créer le scree plot
par(mfrow = c(1, 2), mar = c(4, 4, 2, 1))
plot(1:length(eigen_result$values), eigen_result$values,
type = "b", pch = 16, col = "blue",
xlab = "Composantes Principales", ylab = "Valeurs Propres",
main = "Scree Plot des valeurs propres")
plot(1:length(eigen_result$values), cumulative_proportion,
type = "b", pch = 16, col = "red",
xlab = "Composantes Principales", ylab = "Variabilité Cumulative Expliquée",
main = "Variabilité Cumulative Expliquée")
par(mfrow = c(1, 1))
# Sélectionner le nombre de composantes principales à conserver (par exemple, les deux premières)
num_components <- 2
selected_components <- eigen_result$vectors[, 1:num_components]
(selected_components <- eigen_result$vectors[, 1:num_components])
eigen_result
# Transformation des données
principal_components <- as.matrix(scaled_features) %*% selected_components
# Transformation des données
(principal_components <- as.matrix(scaled_features) %*% selected_components)
# Affichage des résultats
print("Matrice des composantes principales :")
print(principal_components)
# Visualisation des données transformées
plot(principal_components, col = iris$Species, pch = 16, main = "ACP des données Iris", ylab="", xlab="")
legend("topright", legend = levels(iris$Species), col = 1:3, pch = 16)
# Ajouter des étiquettes aux axes
xlabel <- sprintf("Composante Principale %d", 1)
ylabel <- sprintf("Composante Principale %d", 2)
title(xlab = xlabel, ylab = ylabel)
library(scatterplot3d)
colors <- c("setosa" = "red", "versicolor" = "green", "virginica" = "blue")
scatterplot3d(
transformed_data,
color = colors[iris$Species],
pch = 16,
main = "ACP des données Iris (3 premières composantes principales)",
xlab = "Composante Principale 1",
ylab = "Composante Principale 2",
zlab = "Composante Principale 3"
)
scatterplot3d(
principal_components,
color = colors[iris$Species],
pch = 16,
main = "ACP des données Iris (3 premières composantes principales)",
xlab = "Composante Principale 1",
ylab = "Composante Principale 2",
zlab = "Composante Principale 3"
)
legend("topright", legend = levels(iris$Species), fill = colors, pch = 16)
# # Créer le scree plot
par(mfrow = c(1, 2), mar = c(4, 4, 2, 1))
plot(1:length(eigen_result$values), eigen_result$values,
type = "b", pch = 16, col = "blue",
xlab = "Composantes Principales", ylab = "Valeurs Propres",
main = "Scree Plot des valeurs propres")
plot(1:length(eigen_result$values), cumulative_prop_var,
type = "b", pch = 16, col = "red",
xlab = "Composantes Principales", ylab = "Variabilité Cumulative Expliquée",
main = "Variabilité Cumulative Expliquée")
# Creation du bi-plot
par(mfrow = c(1, 1))
centered_data <- scale(iris[, 1:4])
biplot(prcomp(centered_data), cex = 0.7)
# # Créer le scree plot
par(mfrow = c(1, 2), mar = c(4, 4, 2, 1))
plot(1:length(eigen_result$values), eigen_result$values,
type = "b", pch = 16, col = "blue",
xlab = "Composantes Principales", ylab = "Valeurs Propres",
main = "Scree Plot des valeurs propres")
plot(1:length(eigen_result$values), cumulative_prop_var,
type = "b", pch = 16, col = "red",
xlab = "Composantes Principales", ylab = "Variabilité Cumulative Expliquée",
main = "Variabilité Cumulative Expliquée")
plot(1:length(eigen_result$values), cumulative_proportion,
type = "b", pch = 16, col = "red",
xlab = "Composantes Principales", ylab = "Variabilité Cumulative Expliquée",
main = "Variabilité Cumulative Expliquée")
plot(1:length(eigen_result$values), eigen_result$values,
type = "b", pch = 16, col = "blue",
xlab = "Composantes Principales", ylab = "Valeurs Propres",
main = "Scree Plot des valeurs propres")
plot(1:length(eigen_result$values), cumulative_proportion,
type = "b", pch = 16, col = "red",
xlab = "Composantes Principales", ylab = "Variabilité Cumulative Expliquée",
main = "Variabilité Cumulative Expliquée")
print(principal_components)
# Visualisation des données transformées
plot(principal_components, col = iris$Species, pch = 16, main = "ACP des données Iris", ylab="", xlab="")
legend("topright", legend = levels(iris$Species), col = 1:3, pch = 16)
# Ajouter des étiquettes aux axes
xlabel <- sprintf("Composante Principale %d", 1)
ylabel <- sprintf("Composante Principale %d", 2)
title(xlab = xlabel, ylab = ylabel)
library(scatterplot3d)
colors <- c("setosa" = "red", "versicolor" = "green", "virginica" = "blue")
scatterplot3d(
principal_components,
color = colors[iris$Species],
pch = 16,
main = "ACP des données Iris (3 premières composantes principales)",
xlab = "Composante Principale 1",
ylab = "Composante Principale 2",
zlab = "Composante Principale 3"
)
legend("topright", legend = levels(iris$Species), fill = colors, pch = 16)
# # Créer le scree plot
par(mfrow = c(1, 2), mar = c(4, 4, 2, 1))
matrice = matrix(c(4.71, 8.75, 95.29, 91.75), nrow = 2, ncol = 2)
(matrice = matrix(c(4.71, 8.75, 95.29, 91.75), nrow = 2, ncol = 2))
fisher.test(matrice)
chisq.test((matrice))
(matrice = matrix(c(13.04, 5.36, 100-13.04, 100-5.36), nrow = 2, ncol = 2))
(matrice = matrix(c(13.04,100-13.04 , 5.36, 100-5.36), nrow = 2, ncol = 2))
chisq.test((matrice))
(matrice = matrix(c(17.31,100-17.31 , 8.25, 100-8.25), nrow = 2, ncol = 2))
chisq.test((matrice))
install.packages("randomForest")
library(randomForest)
data(iris)
iris
# Préparation des données 70 apprentissage et 30 de test
set.seed(123)
train_idx = sample(1:nrow(iris), 0.7*nrow(iris))
(train_idx = sample(1:nrow(iris), 0.7*nrow(iris)))
(train_idx = sample(1:nrow(iris), 0.7*nrow(iris)))
# Préparation des données 70 apprentissage et 30 de test
(set.seed(123))
data(iris)
# Préparation des données 70 apprentissage et 30 de test
(set.seed(123))  #Dit à R de commencer à prendre les valeurs aux lignes 1 2 3
# Ressort 70% des lignes
(train_idx = sample(1:nrow(iris), 0.7*nrow(iris)))
train_data = iris[train_idx,]
test_data = iris[-train_data,]
test_data = iris[-train_idx,]
(train_data = iris[train_idx,])
(test_data = iris[-train_idx,])
dim(test_data)
dim(train_data)
help(randomForest)
rf_model = randomForest(Species ~ ., data = train_data, ntree = 100)
# Prédiction de l'espèce en fonction des autres variables en utilisant 100 arbres
(rf_model = randomForest(Species ~ ., data = train_data, ntree = 100))
(predictions = predict(rf_model, test_data))
(accuracy = sum(predictions == test_data$Species) / nrow(test_data))
predictions == test_data$Species
sum(predictions == test_data$Species)
features_importance = importance(rf_model)
help(importance)
# Extrait les variables les plus importantes
(features_importance = importance(rf_model))
(sorted_importance = feature_importance[order(-feature_importance),])
(sorted_importance = features_importance[order(-feature_importance),])
(sorted_importance = features_importance[order(-features_importance),])
barplot(sorted_importance, horiz = T, main = "Importance des Caractéristiques", xlab = "Scored d'imporatnc",
cexnames =0.8, las = 1)
barplot(sorted_importance, horiz = T, main = "Importance des Caractéristiques", xlab = "Scored d'imporatnc",
cex.names =0.8, las = 1)
barplot(sorted_importance, horiz = T, main = "Importance des Caractéristiques", xlab = "Scored d'imporatnc",
cex.names =0.8, las = 1)
barplot(sorted_importance, horiz = F, main = "Importance des Caractéristiques", xlab = "Scored d'importance",
cex.names =0.8, las = 1)
library(ggplot2)
ggplot(geom_bar(data = sorted_importance))
(sorted_importance = features_importance[order(-features_importance),])
df = as.data.frame(sorted_importance)
ggplot(geom_bar(data = sorted_importance))
ggplot(geom_bar(data = df))
(df = as.data.frame(sorted_importance))
ggplot(geom_bar(data = df))
ggplot(df +
ggplot(df, geom_bar(stat = "identity", position = "dodge") +
ggplot(df, geom_bar(stat = "identity", position = "dodge") ,labs(x = "Réaction", y = "Valeur", fill = "Traitement"),theme_minimal()
ggplot(df, geom_bar(stat = "identity", position = "dodge"),theme_minimal())
ggplot(df, geom_bar(stat = "identity", position = "dodge") ,labs(x = "Réaction", y = "Valeur", fill = "Traitement"),theme_minimal())
ggplot(df, aes(x = r, y = valeur[1:2] , fill = colnames(vac2))) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Réaction", y = "Valeur", fill = "Traitement") +
theme_minimal())
ggplot(df, aes(x = r, y = valeur[1:2] , fill = colnames(vac2))) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Réaction", y = "Valeur", fill = "Traitement") +
theme_minimal())
ggplot(df, aes(x = r, y = valeur[1:2] , fill = colnames(vac2))) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Réaction", y = "Valeur", fill = "Traitement") +
theme_minimal()
ggplot(df, aes(x = row.names(df), y = df$sorted_importance , fill = colnames(vac2))) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Réaction", y = "Valeur", fill = "Traitement") +
theme_minimal()
barplot(sorted_importance, horiz = F, main = "Importance des Caractéristiques", xlab = "Scored d'importance",
cex.names =0.8, las = 1)
barplot(sorted_importance, horiz = T, main = "Importance des Caractéristiques", xlab = "Scored d'importance",
cex.names =0.8, las = 1)
barplot(sorted_importance, horiz = F, main = "Importance des Caractéristiques", xlab = "Scored d'importance",
cex.names =0.8, las = 1)
print("Enculé")
setwd("C:/Users/Edmond/OneDrive - Université Côte d'Azur/Documents/Cours/Cours Polytech/GB4/S1/Stat/Projet-R-GB4")
data = read.csv("LC-Adductomics.csv")
# Mise en forme des données
albumine = c(data$Albumin.adduct.of.Nacetylcysteine , data$Albumin.adduct.of.CysGly ,
data$Albumin.unadducted , data$Albumin.adduct.of.sulfonic.acid)
type_albumine = rep(c("Albumin.adduct.of.Nacetylcysteine", "Albumin.adduct.of.CysGly",
"Albumin.unadducted", "Albumin.adduct.of.sulfonic.acid"), each = 197)
data3 = data.frame(albumine, type_albumine)
library(ggplot2)
# boxplot général pour voir que c'est la d Les points en dehors des traits sont aberrants
ggplot(data3, aes(x=type_albumine,y=albumine, fill=type_albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")
# Zoom pour mieux voir
ggplot(data3, aes(x=type_albumine,y=albumine, fill=type_albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")+
ylim(c(0,10))
# Filtrer les données
(albu_non_undu <- data3[data3$type_albumine == "Albumin.adduct.of.CysGly",])
# Filtrer les données
(albu_CysGly <- data3[data3$type_albumine == "Albumin.adduct.of.CysGly",])
mean(albu_CysGly)
mean(albu_CysGly$albumine)
mean(data$Albumin.adduct.of.CysGly)
# Calculer les valeurs aberrantes
outliers <- boxplot.stats(data$Albumin.adduct.of.CysGly)$out
# Calculer les valeurs aberrantes
(outliers <- boxplot.stats(data$Albumin.adduct.of.CysGly)$out)
# Calculer les valeurs aberrantes
(outliers <- boxplot.stats(albu_CysGly$albumine)$out)
help(which)
# Afficher les valeurs aberrantes
index_outliers = which(data$Albumin.adduct.of.CysGly in c(outliers))
# Afficher les valeurs aberrantes
index_outliers = which(data$Albumin.adduct.of.CysGly %in% c(outliers))
# Afficher les valeurs aberrantes
(index_outliers = which(data$Albumin.adduct.of.CysGly %in% c(outliers)))
data[19]
data[,19]
data$Albumin.adduct.of.CysGly[index_outliers,]
albu_CysGly[index_outliers,]
albu_CysGly$albumine[index_outliers] = NaN
albu_CysGly
boxplot(albu_CysGly)
boxplot(albu_CysGly$albumine)
boxplot(data$Albumin.adduct.of.CysGly)
boxplot(albu_CysGly$albumine)
# Filtrer les données
(albu_Nacetyl <- data3[data3$type_albumine == "Albumin.adduct.of.Nacetylcysteine",])
# Calculer les valeurs aberrantes
# Prend les valeurs supérieures ou inférieurs aux quartiles +-1.5 fois l'écart interquartile
(outliers <- boxplot.stats(data$Albumin.adduct.of.Nacetylcysteine)$out)
# Afficher les indes des valeurs aberrantes
(index_outliers = which(data$Albumin.adduct.of.Nacetylcysteine %in% c(outliers)))
# Suppression des valeurs aberrantes
albu_Nacetyl$albumine[index_outliers] = NaN
boxplot(albu_CysGly$albumine)
boxplot(albu_Nacetyl$albumine)
boxplot(data$Albumin.adduct.of.Nacetylcysteine)
boxplot(albu_Nacetyl$albumine)
# Filtrer les données
(albu_Nacetyl <- data3[data3$type_albumine == "Albumin.adduct.of.sulfonic.acid",])
# Calculer les valeurs aberrantes
# Prend les valeurs supérieures ou inférieurs aux quartiles +-1.5 fois l'écart interquartile
(outliers <- boxplot.stats(data$Albumin.adduct.of.sulfonic.acid)$out)
# Filtrer les données
(albu_Nacetyl <- data3[data3$type_albumine == "Albumin.adduct.of.Nacetylcysteine",])
# Filtrer les données
(albu_sulfo <- data3[data3$type_albumine == "Albumin.adduct.of.sulfonic.acid",])
# Calculer les valeurs aberrantes
# Prend les valeurs supérieures ou inférieurs aux quartiles +-1.5 fois l'écart interquartile
(outliers <- boxplot.stats(data$Albumin.adduct.of.sulfonic.acid)$out)
# Afficher les indes des valeurs aberrantes
(index_outliers = which(data$Albumin.adduct.of.sulfonic.acid %in% c(outliers)))
# Suppression des valeurs aberrantes
albu_sulfo$albumine[index_outliers] = NaN
boxplot(albu_sulfo$albumine)
# Filtrer les données
(albu_non_undu <- data3[data3$type_albumine == "Albumin.unadducted",])
# Calculer les valeurs aberrantes
# Prend les valeurs supérieures ou inférieurs aux quartiles +-1.5 fois l'écart interquartile
(outliers <- boxplot.stats(data$Albumin.unadducted)$out)
# Calculer les valeurs aberrantes
# Prend les valeurs supérieures ou inférieurs aux quartiles +-1.5 fois l'écart interquartile
(outliers <- boxplot.stats(data$Albumin.unadducted)$out)
# Afficher les indes des valeurs aberrantes
(index_outliers = which(data$Albumin.unadducted %in% c(outliers)))
# Suppression des valeurs aberrantes
albu_non_undu$albumine[index_outliers] = NaN
boxplot(albu_non_undu$albumine)
boxplot(albu_sulfo$albumine)
val_albu = c(albu_CysGly$albumine, albu_Nacetyl$albumine, albu_sulfo$albumine, albu_non_undu$albumine)
val_albu = c(albu_CysGly$albumine, albu_Nacetyl$albumine, albu_sulfo$albumine, albu_non_undu$albumine)
type_Albumine = c(albu_CysGly$type_albumine, albu_Nacetyl$type_albumine, albu_sulfo$type_albumine, albu_non_undu$type_albumine)
data_corr = data.frame(val_albu, type_Albumine)
data_corr
library(ggplot2)
# boxplot général pour voir que c'est la d Les points en dehors des traits sont aberrants
ggplot(data_corr, aes(x=type_a=Albumine,y=val_albu, fill=type_Albumine)) +
# boxplot général pour voir que c'est la d Les points en dehors des traits sont aberrants
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")
# boxplot général pour voir que c'est la d Les points en dehors des traits sont aberrants
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines", center)
helpt(ggtitle)
help(ggtitle)
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines", center)+
ylim(c(0,10))
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")+
ylim(c(0,10))
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")+
ylim(c(0,5))
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")+
ylim(c(0,10))
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")+
ylim(c(0,5))
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")+
ylim(c(0,1))
boxplot(albu_Nacetyl$albumine)
# Filtrer les données
(albu_Nacetyl <- data3[data3$type_albumine == "Albumin.adduct.of.Nacetylcysteine",])
# Calculer les valeurs aberrantes
# Prend les valeurs supérieures ou inférieurs aux quartiles +-1.5 fois l'écart interquartile
(outliers <- boxplot.stats(data$Albumin.adduct.of.Nacetylcysteine)$out)
# Afficher les indes des valeurs aberrantes
(index_outliers = which(data$Albumin.adduct.of.Nacetylcysteine %in% c(outliers)))
# Suppression des valeurs aberrantes
albu_Nacetyl$albumine[index_outliers] = NaN
boxplot(albu_Nacetyl$albumine)
# Filtrer les données
(albu_sulfo <- data3[data3$type_albumine == "Albumin.adduct.of.sulfonic.acid",])
# Calculer les valeurs aberrantes
# Prend les valeurs supérieures ou inférieurs aux quartiles +-1.5 fois l'écart interquartile
(outliers <- boxplot.stats(data$Albumin.adduct.of.sulfonic.acid)$out)
# Afficher les indes des valeurs aberrantes
(index_outliers = which(data$Albumin.adduct.of.sulfonic.acid %in% c(outliers)))
# Suppression des valeurs aberrantes
albu_sulfo$albumine[index_outliers] = NaN
boxplot(albu_sulfo$albumine)
# Filtrer les données
(albu_non_undu <- data3[data3$type_albumine == "Albumin.unadducted",])
# Calculer les valeurs aberrantes
# Prend les valeurs supérieures ou inférieurs aux quartiles +-1.5 fois l'écart interquartile
(outliers <- boxplot.stats(data$Albumin.unadducted)$out)
# Afficher les indes des valeurs aberrantes
(index_outliers = which(data$Albumin.unadducted %in% c(outliers)))
# Suppression des valeurs aberrantes
albu_non_undu$albumine[index_outliers] = NaN
boxplot(albu_non_undu$albumine)
val_albu = c(albu_CysGly$albumine, albu_Nacetyl$albumine, albu_sulfo$albumine, albu_non_undu$albumine)
type_Albumine = c(albu_CysGly$type_albumine, albu_Nacetyl$type_albumine, albu_sulfo$type_albumine, albu_non_undu$type_albumine)
data_corr = data.frame(val_albu, type_Albumine)
data_corr
library(ggplot2)
# boxplot général pour voir que c'est mieux
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines", center)
# boxplot général pour voir que c'est mieux
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")+
ylim(c(0,1))
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")+
ylim(c(0,10))
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")+
ylim(c(0,5))
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")+
ylim(c(0,2))
ggplot(data_corr, aes(x=type_Albumine,y=val_albu, fill=type_Albumine)) +
geom_boxplot()+
xlab(label = "Différents types d'albumines") +
ylab(label = "Concentration") +
theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))+
theme(legend.position="none")+
ggtitle("Boxplot des différentes albumines")+
ylim(c(0,1))
data_corr
data$CysGly_cor = albu_CysGly$albumine
data$Nacetyl_corr = albu_Nacetyl$albumine
data$sulfo_corr = albu_sulfo$albumine
data$unadducted_corr = albu_non_undu$albumine
pairs(data$CysGly_cor, data$unadducted_corr, data$sulfo_corr, data$Nacetyl_corr)
data$sulfo_corr = albu_sulfo$albumine
pairs(data$CysGly_cor, data$unadducted_corr, data$sulfo_corr, data$Nacetyl_corr)
pairs(dataframe(c(data$CysGly_cor, data$unadducted_corr, data$sulfo_corr, data$Nacetyl_corr)))
pairs(data.frame(c(data$CysGly_cor, data$unadducted_corr, data$sulfo_corr, data$Nacetyl_corr)))
pairs(data.frame(data$CysGly_cor, data$unadducted_corr, data$sulfo_corr, data$Nacetyl_corr))
